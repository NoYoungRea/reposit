# 자료구조
## array
- 동적할당 배열과 동적 배열은 서로 다르다.  동적 할당 배열도 배열이 할당될때 크기가 고정된다.

- 기존 배열의 한계점
1. 메서드로 뺐을때의 문제점->배열의 크기 정보가 없음(포인터로 받기 때문에)
2. 배열의 범위를 넘어설 경우를 알 수 없음.
3. 배열의 크기를 조절할 수 없다.
- 동적배열 만들때 팁
1. 스택 메모리는 사용하지 말자 웬만하면 다 힙에 처 넣자. ex)구조체 생성시 힙에 생성,배열 동적할당
2. 사용자가 라이브러리를 사용할때 직관적으로 사용할 수 있게 해야 한다. ex) &arr, arr 두개 인자 인관성있게 하나로
3. 에러코드랑 반환값이랑 분리할 필요가 없을 수도 있다.(모호하지 않고 분리가 된다면)
4. 매 함수 리턴 타입 조사
5. 삭제하다. 제거하다 두개는 엄연히 다르다.
4. 특정 위치 삽입, 데이터 제거 loop 말고 memmove
5. 자동증가로만들기 memcpy보다는 calloc(+a사용자 지정) 배열 만들때 값 fix(매크로). calloc 할때 주의할 점은 실패시 null반환하므로 원본의 주소를 잃어버릴 수 있기 때문에 temp에 할당하고 null이 아니면 주소를 복사해 주자.

## list(원형 이중)
1. 사용자에게 메모리 할당 정책을 강요하고 있다.(heap에 할당하여 붙여주는 식으로 했다.) 더미 헤드 또한 마찬가지다. 모두 사용자가 만들어 넣어주게 하자.
2. 이중 환 연결은 reverse가 의미가 없다.
3. void* 는 타입의 안정성이 떨어진다. 사용의 구조체 안에 넣어서 사용하게 끔 한다.
4. node 위치를 처음으로 하면 좋겠지만 사용자에게 너무 큰 제한이다. 어디에 넣더라도 구조체 주소의 첫 위치를 알 수 있게 해야 한다.
5. 매크로를 사용하여 타입을 넘겨줄 수 있다.(c++과 달리 함수 인자로는 타입을 보내줄 수 없기 때문에 이렇게 해결) 뿐만 아니라 내부 구조를 몰라도 약속만 지키면 되기때문에 사용자가 사용하기 힘든 부분은 매크로로 만들어서 사용하게 끔 해야 함.
6. null이 될리가 없기때문에 유효성 검사 다 지움


## hashmap
- hash map은 검색을 빠르게 하기 위한 자료구조
## 기타
1. 배열 선언 할때 일반적으로 왼쪽 인덱스 자리는 비워 놓고 초기화 하는 것이 좋다.(별개의 이야기)
2. 전역 변수는 0으로 초기화되는 점을 이용하자. calloc으로 할당하면 0으로 초기화 된는 것도 알아두자
3. #define ARR_SIZE(a)		(sizeof((a))/sizeof(*(a)))이런식으로 사용도 좋다.!
4. 포인터의 포인터를 보내는 이유 int * arry를 주소로 보내 int** 로 받는 이유는 단순히 * array가 가지고 있는 값을 바꾸는 거면 array를 보내도 상관 없지만 array가 아무 것도 가리키지 않은상태거나 모종의 이유로 주소를 새로 바꿔야 할 경우에는 array를 보내도 적용이 안된다. 즉 ** int를 보내야 값으로 들어가서 수정할 수 있다.  그럼 그럴 경우가 있나? ex) * array를 선언만하고 아무값도 설정 안 했을 경우
5. 연산을 하지 않을 거라면 수를 받는 것이 아니라 숫자를 받는 것이 좋다.
6. 나눗셈이나 나머지 연산 보다는 비트 연산 사용.	


