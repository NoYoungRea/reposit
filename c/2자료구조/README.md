# 자료구조
## array
- 동적할당 배열과 동적 배열은 서로 다르다.  동적 할당 배열도 배열이 할당될때 크기가 고정된다.

- 기존 배열의 한계점
1. 메서드로 뺐을때의 문제점->배열의 크기 정보가 없음(포인터로 받기 때문에)
2. 배열의 범위를 넘어설 경우를 알 수 없음.
3. 배열의 크기를 조절할 수 없다.
- 동적배열 만들때 팁
1. 스택 메모리는 사용하지 말자 웬만하면 다 힙에 처 넣자. ex)구조체 생성시 힙에 생성,배열 동적할당
2. 사용자가 라이브러리를 사용할때 직관적으로 사용할 수 있게 해야 한다. ex) &arr, arr 두개 인자 인관성있게 하나로
3. 에러코드랑 반환값이랑 분리할 필요가 없을 수도 있다.(모호하지 않고 분리가 된다면)
4. 매 함수 리턴 타입 조사
5. 삭제하다. 제거하다 두개는 엄연히 다르다.
4. 특정 위치 삽입, 데이터 제거 loop 말고 memmove
5. 자동증가로만들기 memcpy보다는 calloc(+a사용자 지정) 배열 만들때 값 fix(매크로). calloc 할때 주의할 점은 실패시 null반환하므로 원본의 주소를 잃어버릴 수 있기 때문에 temp에 할당하고 null이 아니면 주소를 복사해 주자.


## list(원형 이중)
1. 사용자에게 메모리 할당 정책을 강요하고 있다.(heap에 할당하여 붙여주는 식으로 했다.) 더미 헤드 또한 마찬가지다. 모두 사용자가 만들어 넣어주게 하자.
2. 이중 환 연결은 reverse가 의미가 없다.
3. void* 는 타입의 안정성이 떨어진다. 사용의 구조체 안에 넣어서 사용하게 끔 한다.
4. node 위치를 처음으로 하면 좋겠지만 사용자에게 너무 큰 제한이다. 어디에 넣더라도 구조체 주소의 첫 위치를 알 수 있게 해야 한다.
5. 매크로를 사용하여 타입을 넘겨줄 수 있다.(c++과 달리 함수 인자로는 타입을 보내줄 수 없기 때문에 이렇게 해결) 뿐만 아니라 내부 구조를 몰라도 약속만 지키면 되기때문에 사용자가 사용하기 힘든 부분은 매크로로 만들어서 사용하게 끔 해야 함.
6. null이 될리가 없기때문에 유효성 검사 다 지움

## 데이터를 스택에 하건 힙에 하건 그게 중요한게 아니라 일관성이 있어야 하며 사용자에게 정책을 알려주어야 한다. 오픈소스 기준으로 1. 처음 array의 경우에는 동적할당할 것이 array와 contents밖에 없었으니깐 생략하고 2. 이중원형 연결리스트에서는 아예 노드 자체를 사용자에게 받아서 추가했다. 스택으로 할 것인지 힙으로 할 것인지 정책을 사용자에게 맡기는 방식이다. (힙으로 할시에 사용자가 지워주어야 한다.) 3. generic hashmap의 경우 데이터를 넘기면 동적 할다을 하여 깊은 복사를 해주는 경우가 있고, 그냥 날라온 데이터를 참조하는 얕은 복사를 해주는 경우가 있다.(오픈 소스에서는 이렇게 했다. 이 경우에는 데이터의 보존을 잘 해야 한다. 전역이라든지 등) 노드는 두 경우 다 내부적으로 동적할당을 했다. 의아한 것이 왜 사용자에게 노드를 만들어 넘기는 식으로 하지 않았을까? 그리고 저런식으로 얕은 내부적으로 얕은 복사를 했다면 스택의 값이 아닌 동적할당된 값을 보낼 것을 대비하여 내부 동작할당을 지워주는 함수를 보내 주었다면 더 수월하게 해제 시키지 않았을까?(물론 main에서 해도 되지만)

## hashmap
- hash map은 검색을 빠르게 하기 위한 자료구조
- Prev를 사용하는 대신에 이중 포인터를 사용하면 편하다. 1.  Current로 판별하고 prev를 통해 참조하여 붙일 필요가 없다. 더미 헤드없이도 이원화를 없앨 수 있다.(즉, 이중 포인터를 이용하여 단일 연결리스트의 더미를 지울 수 있다.)
- 댕글릴 포인터 : 이미 사라진 메모리를 참조하고 있다. ->스택을 얕은 복사로 참조하는 경우 스택이 사라지면 댕글링 포인터가 된다. 그러므로 (난 그래서 스택 대신 힙을 사용했다..) 깊은 복사를 해 주는 것이 좋다. Old value의 경우 사용자가 해제를 해 주어야 한다. 반면 List에서 다른 함수에서 객체를 생성해주지는 말자. Main에서 만들거나 전역으로 만들어서 해결!!!! 사용자가 잘 인지하고 사용해야 한다.
- 헤쉬맵 두가지 방법(list,array)-> 후자를 사용하는 이유는 동적할당 오버해드. 결정적인 이유는 필요한 순간마다 동적할당을 한다면, 너무 낭비가 심하다.(배그 총알). And 사용메모리보다 더 많은 메모리 할당시에 메모리 낭비(그거 말하는 듯. 키에 대한 인덱스에서 참조하지 않는 인덱스들도 많지 않을까? 반면 후자는 인덱스 목록을 만들어 놓는 것이 아니라 인덱스를 필요할때마다..) but 두번째 방법은 활용성이 낮다.
- 제네릭의 경우에는 사용자로부터 Hash를 받아서 사용하고 그것을 다시 한번 내부적으로 프로세싱을 거쳐서(더 잘 분산시키기 위해서) 인덱스 값을 구한다.
## 기타
1. 배열 선언 할때 일반적으로 왼쪽 인덱스 자리는 비워 놓고 초기화 하는 것이 좋다.(별개의 이야기)
2. 전역 변수는 0으로 초기화되는 점을 이용하자. calloc으로 할당하면 0으로 초기화 된는 것도 알아두자
3. #define ARR_SIZE(a)		(sizeof((a))/sizeof(*(a)))이런식으로 사용도 좋다.!
4. 포인터의 포인터를 보내는 이유 int * arry를 주소로 보내 int** 로 받는 이유는 단순히 * array가 가지고 있는 값을 바꾸는 거면 array를 보내도 상관 없지만 array가 아무 것도 가리키지 않은상태거나 모종의 이유로 주소를 새로 바꿔야 할 경우에는 array를 보내도 적용이 안된다. 즉 ** int를 보내야 값으로 들어가서 수정할 수 있다.  그럼 그럴 경우가 있나? ex) * array를 선언만하고 아무값도 설정 안 했을 경우
5. 연산을 하지 않을 거라면 수를 받는 것이 아니라 숫자를 받는 것이 좋다.
6. 나눗셈이나 나머지 연산 보다는 비트 연산 사용.	
7. %모듈러스 비트를 이용하여 가능->1%4->1&(4-1); 단 이때 4는 반드시 2의 승수



