# 자료구조
## array
- 동적할당 배열과 동적 배열은 서로 다르다.  동적 할당 배열도 배열이 할당될때 크기가 고정된다.

- 기존 배열의 한계점
1. 메서드로 뺐을때의 문제점->배열의 크기 정보가 없음(포인터로 받기 때문에)
2. 배열의 범위를 넘어설 경우를 알 수 없음.
3. 배열의 크기를 조절할 수 없다.
- 동적배열 만들때 팁
1. 스택 메모리는 사용하지 말자 웬만하면 다 힙에 처 넣자. ex)구조체 생성시 힙에 생성,배열 동적할당
2. 사용자가 라이브러리를 사용할때 직관적으로 사용할 수 있게 해야 한다. ex) &arr, arr 두개 인자 인관성있게 하나로
3. 에러코드랑 반환값이랑 분리할 필요가 없을 수도 있다.(모호하지 않고 분리가 된다면)
4. 매 함수 리턴 타입 조사
5. 삭제하다. 제거하다 두개는 엄연히 다르다.
4. 특정 위치 삽입, 데이터 제거 loop 말고 memmove
5. 자동증가로만들기 memcpy보다는 calloc(+a사용자 지정) 배열 만들때 값 fix(매크로). calloc 할때 주의할 점은 실패시 null반환하므로 원본의 주소를 잃어버릴 수 있기 때문에 temp에 할당하고 null이 아니면 주소를 복사해 주자.

## 기타
1. 배열 선언 할때 일반적으로 왼쪽 인덱스 자리는 비워 놓고 초기화 하는 것이 좋다.(별개의 이야기)
2. 전역 변수는 0으로 초기화되는 점을 이용하자. calloc으로 할당하면 0으로 초기화 된는 것도 알아두자
3. #define ARR_SIZE(a)		(sizeof((a))/sizeof(*(a)))이런식으로 사용도 좋다.!
4. 포인터의 포인터를 보내는 이유 int *arry를 주소로 보내 int**로 받는 이유는 단순히 *array가 가지고 있는 값을 바꾸는 거면 array를 보내도 상관 없지만 array가 아무 것도 가리키지 않은상태거나 모종의 이유로 주소를 새로 바꿔야 할 경우에는 array를 보내도 적용이 안된다. 즉 **int를 보내야 값으로 들어가서 수정할 수 있다.  그럼 그럴 경우가 있나? ex) *array를 선언만하고 아무값도 설정 안 했을 경우
