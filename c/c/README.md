# 놓치기 쉬운 C 개념

# 단계

1. a.c(소스코드,원시코드,텍스트(사람이 볼수 있다는 뜻)->cpp(c Preprocessor) by D:\> cl.exe a.c /P
2. a.i(전처리된 파일 또는 코드, 텍스트)->c compiler by D:\> cl.exe a.c /FAs
3. a.asm(어셈블리 코드, 텍스트) by cl.exe a.c(이거 하나면 사실 끝나지만 단계별 과정을 보고 싶으면 위 명령어 사용!!)
4. a.obj(목적파일)
- 어떠한 언어를 다른 언어로 만드는 것을 컴파일러라고 한다. 즉, c언어에서 목적 파일로 되는 것을 컴파일이라고 하지 않는다.
기계어와 1대1로 대응되며 사람이 읽을 수 있는 언어를 니모닉 언어라고 한다. 그 중 하나가 어셈블리 언어다. c언어를 어셈블리어로 만든 것을 컴파일이라 하며 어셈블리 언어로 부터 목적파일이 만들어지는 것은 별개의 일이다. 컴파일이 끝나면 어셈블리와 1대1로 대응되는 기계어(목적 파일)이 생성되니 착각하는 것


## 포인터
1. 보이드 포인터 : 모든 타입을 다 담을 수 있다. but 타입의 안정성이 떨어진다. ->다른 언어들은 reflector 가지고 현재 객체가 무슨 객체인지 알 수 있음.

## 주소
hdd로부터 램에 로드를 한다음 거기로 부터 cpu가 접근을 해야 하는데, 그러기 위해 주소를 사용함(방 번호)
와이어의 갯수가 n일때 방의 갯수는 2의 n승이다.
주소란 렘이란 주기억 장치에 접근하기 위해 부여한 방번호인데, 0부터 시작하는 양의 정수이다.
윈도우 xp는 32비트 운영체제.(cpu가 한번에 처리할 수 있는 단위) ram으로 부터 데이터를 끌어올때 좋던 싫던 32비트씩 가져옴.(주소를 할당해주는 선을 주소선, 데이터를 가져오는 선을 데이터 선이라 한다.) 데이터 선이 32가닥
->너무 비싸다. so 데이터선을 주소선과 공유 즉 2의 32승 즉 4g즉 4g바이트 그래서 윈도우에서는 4g이상의 렘을 사용해도 의미가 없음.(4g이상 할당할 수가 없다.)
->정수의 승격이 되는 이유 char c=64 이라 해서 1바이트 할당 노노, 32가닥으로 즉 인티저 형으로 승격됨.
## 주소 연산
운영체제는 프로그래밍을 실행할때 가상메모리를 잡아준다. 만약 프로그래밍이 실행하다가 운영체제가 허가하지 않은 메모리에 접근하면 운영체제는 프로그램을 죽여버린다.
즉, 주소끼리의 덧셈은 무의미한 값이 나올 가능성이 높아 포인터끼리의 덧셈을 막아놓는다. but 뻴셈은 유의미 하다. 두 주소간의 거리를 알 수 있기때문에 유의미하다. 두 위치사이의 뺄셈은 양의 개념인 정수가 나온다. (not 위치 개념)
## 배열 4종류
1. 그냥 스택에 다 때려박는 경우(매우 무거움)
2. 열만 고정하는 경우 : 힙에 있지만 낭비가 심하고 재활용성 떨어짐
3. 행은 스택에 열은 힙에 놓는 경우 : 여전히 무거움
4. 행과 열 모두 힙에 놓는 경우 : 
->2중 포인터로 배열 구현한거(zagged array 톱니바퀴 행렬) : 배열이 아님 연속적이지 않음. 중간에 겝이 있음. (자바에서 만든 2차형 배열이 이런식임:연속적이라고 가정하지 말라고 써 있음.)

- 배열의 이름은 시작 주소를 의미하는 상수 포인터이다. 
(타입 : int *const p) 
- 예외가 되는 것은 sizeof연산자를 사용할때다.

## 매크로
1. 메크로의 경우 리터럴의 경우는 컴파일이 다 끝나서 나옴 즉, 2*2가 아니라 4로.피연산자가 상수만 있는 것을 상수 표현식이라고 하는데, 이런 표현식은 컴파일 단계에서 다 끝나버림.
2. 함수를 호출하는 것도 무겁기 때문에(인수가 스택에 쌓이는 등) 매크로를 잘 사용하면 좋지만 주의 할 점 3가지
- 매크로를 견고하게 만드는 방법 1. 매크로 함수의 모든 인자에 괄호를 사용하라!
- 매크로를 견고하게 만드는 방법 2. 치환될 매크로의 최 외곽에도 괄호를 사용하라!
- 매크로를 견고하게 만드는 방법 3. 매크로 상수에 괄호를 사용하라
- 매크로를 견고하게 만드는 방법 4. ++ 같은거 사용하지 않기!
3. 미리 정의된 매크로 (ex) line
4. 두 단계 매크로
5. 매크로 연산자

## inline
1. 일반 함수를 쓰자니 성능상 문제 메크로를 쓰자니 부작용이 많다. so inline 사용
2. inline은 함수가 호출된 자리에 함수의 기계어 코드를 때려 박는다.(어셈블리 코드를 보면 확인 가능)
3. 무조건 되는 것은 아니고 cl을 사용하여 컴파일 할 경우 cl a.c /FMs /ob1 최적화 옵션을 주어야 동작한다. vs에서는 릴리즈 버전으로 컴파일 하면 들어가고 무조건 되게 설정도 가능
4. inline은 컴파일 단계에서 쑤셔 넣는 것이므로 런타임 까지 가봐야 아는 것들에 대해서는 적용되지 않는다. 
- 너무 길어도 적용되지 않고(2~3줄 함수에 권장, 안 그러면 목적 파일이 커짐)
- 함수 포인터로 호출해도 적용 안 됨(무엇을 호출할지는 런타임에서 결정하기 때문에)
- 재귀의 경우에도 적용되지 않는다. (c++은 된다는 듯)
5. inline으로 안 되는 것은 매크로로

  
## include guard
- 컴파일러는 한번에 하나의 파일밖에 해석을 못한다. 다른 파일의 것을 참조하려면 헤더파일사용해야 한다. 선언은 여러번 해도 상관없지만, 정의는 여러번 오면 안된다. 즉 헤더 파일도 중복해서 사용하여 정의부가 중복되면 클난다. 인클루드 가드 사용!!!!!!!!!!!!!!!!!!!!

- #pragma once 처 쓰지 말고(비 표준 for window)
1. #ifndef a
2. #define a
3. #endif

## 방어적 코딩? 및 알면 좋은 기타 사항
### 동적 할당도 비용이 드는 거다. 그리고 할당이 안 될 수도 있다.
### 함수 호출도 비용이 든다. 함수 호출 오버해드
### 모든 에러가 컴파일 타임에 나도록 유도해야 한다.
### 바뀌지 않는 곳에서 인자를 받을때 const 사용. 
### asert
- 취약성이 될 수 있는 소프트웨어의 결점을 찾아내는데 효과적인 도구(적절히 사용하면 if 보다 좋음, 패킷같은거 내가 지정한 것 과 갯수 다른 경우 ex) 
안드로이드 단말기 에서 gcc로 컴파일러로 돌렸을때 구조체 사이에 생기는 패딩과, c언어 를 vs로 돌렸을때는 결과가 다르다. 서로 크기 같게 해서 보냈는데 만약 다를 경우 assert로 해결 )
1. abort 함수를 호출하므로 서버나 임베디드 시스템에는 사용하기가 부적합 함(갑자기 꺼짐!)
2. 함수이므로 반드시 프로그램이 구동되어야만 검사 가능함(런타임 오버헤드가 발생)
3. 경우에 따라서는 동작하지 않을 수도 있음.
- solution 런타임에 구동되는 함수가 아니라 매크로를 사용하여 컴파일 에러로 그 전에 걸러주는 역활을 하자. 컴파일에 어설트 하는 기능을 static assert라고 하는데 c 언어에는 없음.
1. 컴파일 에러에 걸리는 문법을 이용할텐데 (ex) 실패시 arr[-1]) 성공시 arr[1]이 되어 데이터를 잡아먹지 않게 하자. ->typedef
2. __LINE__ 을 집어넣어 중복을 피하자.

## 매직넘버를 회피하는 방법
1. const 상수 : 단점: 메모리 낭비, 분기문(switch)에 사용 불가능 장점 : 디버깅 할 때 쉬움(심볼이 컴파일 후에도 남는다.)
2. 매크로 상수 : 추가될때 유지보수가 그닥 좋지 않음. 비싼 컴파일러는 전처리기에서 사용한 심볼까지 컴파일에게 다 넘겨주지만, 일반적으로는 그렇지 않다. 즉, 디버깅이 어려움.
3. enum->컴파일러가 심볼정보를 다 알고 있음 디버깅이 쉬움, 유지보수 쉬움, 메모리를 잡아먹지도 않음. 
단점 :  int형 0과 호환되고 또 이 0에 해당하는 다른 enum도 출입 가능.(c++이나 자바에서는 0이나 다른 것 호환 안됨. 컴파일 에러)

## 함수 선언
- 함수 선언 안 하고 사용하면 인수 안 맞춰도 컴파일 가능하므로 선언 해주도록 하자.

## #pragma
- #pragma 의 경우 컴파일러에 정보를 전달할 수 있고 이중 message의 경우 사용자 메세지를 보낼 수 있다.

