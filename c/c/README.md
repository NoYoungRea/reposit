# 놓치기 쉬운 C 개념

# 단계

1. a.c(소스코드,원시코드,텍스트(사람이 볼수 있다는 뜻)->cpp(c Preprocessor) by D:\> cl.exe a.c /P
2. a.i(전처리된 파일 또는 코드, 텍스트)->c compiler by D:\> cl.exe a.c /FAs
3. a.asm(어셈블리 코드, 텍스트) by cl.exe a.c(이거 하나면 사실 끝나지만 단계별 과정을 보고 싶으면 위 명령어 사용!!)
4. a.obj(목적파일)
- 어떠한 언어를 다른 언어로 만드는 것을 컴파일러라고 한다. 즉, c언어에서 목적 파일로 되는 것을 컴파일이라고 하지 않는다.
기계어와 1대1로 대응되며 사람이 읽을 수 있는 언어를 니모닉 언어라고 한다. 그 중 하나가 어셈블리 언어다. c언어를 어셈블리어로 만든 것을 컴파일이라 하며 어셈블리 언어로 부터 목적파일이 만들어지는 것은 별개의 일이다. 컴파일이 끝나면 어셈블리와 1대1로 대응되는 기계어(목적 파일)이 생성되니 착각하는 것


## 포인터
1. 보이드 포인터 : 모든 타입을 다 담을 수 있다. but 타입의 안정성이 떨어진다. ->다른 언어들은 reflector 가지고 현재 객체가 무슨 객체인지 알 수 있음.
2. gcc는 포이드 포인터 연산시 1이라 가정하지만, vs는 크기를 알 수 없어서 연산을 할 수 없다.

## 주소
hdd로부터 램에 로드를 한다음 거기로 부터 cpu가 접근을 해야 하는데, 그러기 위해 주소를 사용함(방 번호)
와이어의 갯수가 n일때 방의 갯수는 2의 n승이다.
주소란 렘이란 주기억 장치에 접근하기 위해 부여한 방번호인데, 0부터 시작하는 양의 정수이다.
윈도우 xp는 32비트 운영체제.(cpu가 한번에 처리할 수 있는 단위) ram으로 부터 데이터를 끌어올때 좋던 싫던 32비트씩 가져옴.(주소를 할당해주는 선을 주소선, 데이터를 가져오는 선을 데이터 선이라 한다.) 데이터 선이 32가닥
->너무 비싸다. so 데이터선을 주소선과 공유 즉 2의 32승 즉 4g즉 4g바이트 그래서 윈도우에서는 4g이상의 렘을 사용해도 의미가 없음.(4g이상 할당할 수가 없다.)
->정수의 승격이 되는 이유 char c=64 이라 해서 1바이트 할당 노노, 32가닥으로 즉 인티저 형으로 승격됨.
## 주소 연산
운영체제는 프로그래밍을 실행할때 가상메모리를 잡아준다. 만약 프로그래밍이 실행하다가 운영체제가 허가하지 않은 메모리에 접근하면 운영체제는 프로그램을 죽여버린다.
즉, 주소끼리의 덧셈은 무의미한 값이 나올 가능성이 높아 포인터끼리의 덧셈을 막아놓는다. but 뻴셈은 유의미 하다. 두 주소간의 거리를 알 수 있기때문에 유의미하다. 두 위치사이의 뺄셈은 양의 개념인 정수가 나온다. (not 위치 개념)
## 배열 4종류
1. 그냥 스택에 다 때려박는 경우(매우 무거움)
2. 열만 고정하는 경우 : 힙에 있지만 낭비가 심하고 재활용성 떨어짐
3. 행은 스택에 열은 힙에 놓는 경우 : 여전히 무거움
4. 행과 열 모두 힙에 놓는 경우 : 
->2중 포인터로 배열 구현한거(zagged array 톱니바퀴 행렬) : 배열이 아님 연속적이지 않음. 중간에 겝이 있음. (자바에서 만든 2차형 배열이 이런식임:연속적이라고 가정하지 말라고 써 있음.)

- 배열의 이름은 시작 주소를 의미하는 상수 포인터이다. 
(타입 : int *const p) 
- 예외가 되는 것은 sizeof연산자를 사용할때다.

## 매크로
1. 메크로의 경우 리터럴의 경우는 컴파일이 다 끝나서 나옴 즉, 2*2가 아니라 4로.피연산자가 상수만 있는 것을 상수 표현식이라고 하는데, 이런 표현식은 컴파일 단계에서 다 끝나버림.
2. 함수를 호출하는 것도 무겁기 때문에(인수가 스택에 쌓이는 등) 매크로를 잘 사용하면 좋지만 주의 할 점 3가지
- 매크로를 견고하게 만드는 방법 1. 매크로 함수의 모든 인자에 괄호를 사용하라!
- 매크로를 견고하게 만드는 방법 2. 치환될 매크로의 최 외곽에도 괄호를 사용하라!
- 매크로를 견고하게 만드는 방법 3. 매크로 상수에 괄호를 사용하라
- 매크로를 견고하게 만드는 방법 4. ++ 같은거 사용하지 않기!
3. 미리 정의된 매크로 (ex) line
4. 두 단계 매크로
5. 매크로 연산자

## inline
1. 일반 함수를 쓰자니 성능상 문제 메크로를 쓰자니 부작용이 많다. so inline 사용
2. inline은 함수가 호출된 자리에 함수의 기계어 코드를 때려 박는다.(어셈블리 코드를 보면 확인 가능)
3. 무조건 되는 것은 아니고 cl을 사용하여 컴파일 할 경우 cl a.c /FMs /ob1 최적화 옵션을 주어야 동작한다. vs에서는 릴리즈 버전으로 컴파일 하면 들어가고 무조건 되게 설정도 가능
4. inline은 컴파일 단계에서 쑤셔 넣는 것이므로 런타임 까지 가봐야 아는 것들에 대해서는 적용되지 않는다. 
- 너무 길어도 적용되지 않고(2~3줄 함수에 권장, 안 그러면 목적 파일이 커짐)
- 함수 포인터로 호출해도 적용 안 됨(무엇을 호출할지는 런타임에서 결정하기 때문에)
- 재귀의 경우에도 적용되지 않는다. (c++은 된다는 듯)
5. inline으로 안 되는 것은 매크로로

  
## include guard
- 컴파일러는 한번에 하나의 파일밖에 해석을 못한다. 다른 파일의 것을 참조하려면 헤더파일사용해야 한다. 선언은 여러번 해도 상관없지만, 정의는 여러번 오면 안된다. 즉 헤더 파일도 중복해서 사용하여 정의부가 중복되면 클난다. 인클루드 가드 사용!!!!!!!!!!!!!!!!!!!!

- #pragma once 처 쓰지 말고(비 표준 for window)
1. #ifndef a
2. #define a
3. #endif

## 방어적 코딩? 및 알면 좋은 기타 사항
### 동적 할당도 비용이 드는 거다. 그리고 할당이 안 될 수도 있다.
### 함수 호출도 비용이 든다. 함수 호출 오버해드
### 모든 에러가 컴파일 타임에 나도록 유도해야 한다.
### 바뀌지 않는 곳에서 인자를 받을때 const 사용. 
### 변수가 아니라 상수를 사용했으면 2*2를 컴파일 타임에 4로 바꾼다.
### 나누기 같은 거 하면 무겁다. 비트 연산자 &1을 사용하여 0과 1이 나오는 걸로 판단.
### asert
- 취약성이 될 수 있는 소프트웨어의 결점을 찾아내는데 효과적인 도구(적절히 사용하면 if 보다 좋음, 패킷같은거 내가 지정한 것 과 갯수 다른 경우 ex) 
안드로이드 단말기 에서 gcc로 컴파일러로 돌렸을때 구조체 사이에 생기는 패딩과, c언어 를 vs로 돌렸을때는 결과가 다르다. 서로 크기 같게 해서 보냈는데 만약 다를 경우 assert로 해결 )
1. abort 함수를 호출하므로 서버나 임베디드 시스템에는 사용하기가 부적합 함(갑자기 꺼짐!)
2. 함수이므로 반드시 프로그램이 구동되어야만 검사 가능함(런타임 오버헤드가 발생)
3. 경우에 따라서는 동작하지 않을 수도 있음.
- solution 런타임에 구동되는 함수가 아니라 매크로를 사용하여 컴파일 에러로 그 전에 걸러주는 역활을 하자. 컴파일에 어설트 하는 기능을 static assert라고 하는데 c 언어에는 없음.
1. 컴파일 에러에 걸리는 문법을 이용할텐데 (ex) 실패시 arr[-1]) 성공시 arr[1]이 되어 데이터를 잡아먹지 않게 하자. ->typedef
2. __LINE__ 을 집어넣어 중복을 피하자.

## 매직넘버를 회피하는 방법
1. const 상수 : 단점: 메모리 낭비, 분기문(switch)에 사용 불가능 장점 : 디버깅 할 때 쉬움(심볼이 컴파일 후에도 남는다.)
2. 매크로 상수 : 추가될때 유지보수가 그닥 좋지 않음. 비싼 컴파일러는 전처리기에서 사용한 심볼까지 컴파일에게 다 넘겨주지만, 일반적으로는 그렇지 않다. 즉, 디버깅이 어려움.
3. enum->컴파일러가 심볼정보를 다 알고 있음 디버깅이 쉬움, 유지보수 쉬움, 메모리를 잡아먹지도 않음. 
단점 :  int형 0과 호환되고 또 이 0에 해당하는 다른 enum도 출입 가능.(c++이나 자바에서는 0이나 다른 것 호환 안됨. 컴파일 에러)

## 함수 선언
- 함수 선언 안 하고 사용하면 인수 안 맞춰도 컴파일 가능하므로 선언 해주도록 하자.

## #pragma
- #pragma 의 경우 컴파일러에 정보를 전달할 수 있고 이중 message의 경우 사용자 메세지를 보낼 수 있다.

## c에서 에러 처리
1. 함수의 리턴 값으로 호출부에 에러의 여부를 알린다.
2. 결과 값을 리턴해야 하는 경우 인자로 해당 결과 값을 담을 곳의 포인터를 가져와 저장한다.
3. 함수의 입장에서 매개변수-parameter들을 볼때 (호출 부에서 볼때는 인자-argument) 결과를 저장하는 것을 out-parameter, 나머지를 in-parameter라고 한다. out-parameter의 경우 식별자를 out으로 해주자.(아무 역활을 하지 않는 out 매크로를 만들어 인자 옆에 붙여주기도 한다.) 그리고 수정되지 않고 참조만 하는 in-parameter의 경우에는 const로 설정하여 바꾸지 못하게 하자
4. 반환형을 에러 메세지로 한다는 것을 주석을 사용하지 말고 코드 그 자체가 주석역활을 하게 하자. typedef를 사용하여 typedef int error_t로 하여 누가 봐도 에러 메세지를 반환한다는 것을 알 수 있게 하자.

## 가변인자
- #include<stdarg.h>
- #define VA_END (-1) //센티널
- va_list args;//가변 인자 리스트 선언
- va_start(args,a)//가변 인자 리스트 초기화 여기서 a는 맨 첫번째 인자
- va_arg(args,int)//다음 매개 변수를 해당 크기 만큼 읽어옴
- va_end(args)//가변 인자 리스트 cleanup
1. 반드시 첫 번째 매개변수는 고정되어 있어야 한다.
2. 센티널을 끝에 인자에 넣어 판별하는 법과, 센티널을 사용하지 않고 인자의 갯수를 첫 인자로 받는 방법이 있다.
3. 처음 매개 변수부터 가져오는 것이 아닌 그 다음 것 부터 가져옴.

## 모듈화(파일 단위로 분리)
- 라이브러리를 만드는 사람은 사용자에게 인터페이스를 제공해야 할 의무가 있음 by 헤더파일
### 구조체의 정보 은닉
1. 구조체의 경우 헤더를 구현할때 구조체의 정의부를.h에 넣어 놓고 그 헤더.c에서 포함시키면 그 구조체는 모두가 사용할 수 있다. but 구조체의 맴버들을 은닉하고 싶은 경우에는 구조체의 선언부만 위에 놓고 정의부는 a.c로 빼자. 그럼 b.c에서는 해당 구조체의 포인터는 사용할 수 있지만(불완전한 정의이기 때문에)구조체 그 자체로는 사용하지 못한다. 만약 헤더에 해당 구조체의 포인터를 사용하는 함수가 선언되어 있다면, 해당 함수를 사용할 수 있다. 
->컴파일까지 끝나 여러개의 목적파일이 생겼을때(헤더의 내용까지 넣어) 말이 되는지 생각해 보자.
//typedef struct Node {
//	// ...
//	struct Node* next;	// OK, 포인터의 크기는 이미 결정되어 있기 때문
//	struct Node node;	// ERROR, 타입 정보가 완벽하게 정의되어 있지 않기 때문 
//} Node;

### 함수
1. 딱히 선언부를 헤더로 안 빼놔도 다른 b.c에서 사용가능하다. 다만, 사용자에게 정보를 제공하는 역활로 빼 놓자. 그리고 a.c에서는 함수를 교차해서 쓰기 위해 빼놓자.
2. 자기만 쓰기 위해서 static을 사용한다. 선언부와 정의부에 다 사용가능한 듯 하다.

### 연결성
- 연결성(linkage): 서로 다른 모듈에서 심볼을 연결하는 개념
1. 내부 연결성(internal linkage): 해당 심볼에 대하여 static으로 선언
-> 한 파일 내에서 객체나 함수의 대한 연결은 선언된 파일 내부로 국한
2. 외부 연결성(external linkage): 원칙적으로는 해당 심볼에 대하여 extern을
사용해야 하나 static을 사용하지 않으면 기본적으로 외부 연결성으로 선언됨
- 파일의 범위를 넘어서까지 사용되지 않을 객체나 함수에 대해서는 반드시 static 키워드로
선언해야 합니다.

### 변수
1. 변수는 함수와 달리 선언 부가 없으면 다른 파일에서 사용을 할 수 없다. a.c에서 정의부를 a.h에서 선언부(extern 키워드 넣으려면 여기)를 이를 헤더로 포함한 b.c에서 사용하자.

### inline과 메크로
- 일반 함수의 선언문은 헤더에 있으면 안되지만(컴파일 타임엔 ㄱㅊ but 링크시 에러) 인라인은 컴파일 하는 단계에서 기계어로 박아주는 것이기 때문에 ㄱㅊ 메크로 또한 전처리기 단계에서 해당 기능을 치환해주는 개념이기에 ㄱㅊ
- 매크로나 인라인 모두 internal lingage속성을 가짐.

## 모듈화 정리
헤더 파일 설계 시, 주의할 점
1. 인클루드 가드를 설정해야 합니다.
2. 객체(변수)나 함수는 정의를 하시면 안됩니다.
3. 인라인 함수나 매크로는 헤더 파일에 정의해야 합니다. 단, 타입에 대한 정보는 헤더 파일에 정의할 수 있습니다.(ex)구조체 정의부와 선언부


## restrict
1. 포인터에만 사용할 수 있는 한정자로 그 포인터가 객체에 접근할 수 있는 유일한 수단임을 컴파일러에게 알려주는 역할을 합니다. 포인터가 restrict 키워드로 한정되면 그 포인터가 가리키는 객체는 그 포인터만 접근 가능하므로 컴파일러가 좀 더 적극적인 최적화를 수행할 수 있습니다. 만약 이 한정자를 사용한 포인터에 대하여 같은 객체를 가리키면(참조) 그 결과는 미정의 동작입니다.
2. restrict 는 컴파일러에게 해당 포인터가 가리키는 대상 객체는 다른 포인터가 절대 접근할 수 없다. vs는 memcpy에 restrict안 붙기 때문에 memmove 사용하는 것과 다른 것이 없음 but 다른 컴파일에서 restrict 붙어 있으면 그 경우에는 같은 메모리에 대해 사용하면 안됨. memmove를 사용해야 함. 만약 같은 메모리에 대해서 복사는 memcpy 사용 노노

## volatile
- volatile: 값이 프로그램이 아닌 외부적인 요인에 의하여 그 값이 변경될 수 있다고 컴파일러에게 알려 캐싱을 제한할 때 사용하는 키워드입니다. 따라서 캐시되어서는 안되는 데이터에 대해서는 반드시 volatile을 사용해야 합니다.
- 최적화를 하는 과정에서 함수 호출부가 안 보이기 때문에 flag 값을 계속 가져오기 보다 캐시에 저장을 하고 그것을 쓴다.(물리메모리에서 가져오는 것이 아니라) 이 경우에 volatile을 사용한다.

## 패딩
- 패딩비트(padding bit): CPU가 입출력을 빠르게 하기 위해 컴파일러가 추가하는 메모리 공간
- C99: 구조체 안에는 이름이 없는 패딩(padding)이 들어갈 수 있으며 이 위치는 컴파일러마다 다르게 생성됩니다.
- 결론! 구조체의 크기가 멤버들의 총합이라고 가정하지 말자!

## 입력(0552-7)
1. 스캔f로 사용하는 경우 : int ret = scanf("%d", &age);로 반드시 검사하자.
2. 1번의 단점이 있다면 age의 자료형을 넘는 입력을 하는 경우는 판별할 수 없다. atoi를 사용할 수도 있지만 가장 바람직 한 것은 strtol이다.

## unitmax_t
- long 을 사용할 경우 Windows: 64비트 시스템에서 long은 4바이트 Linux: 64비트 시스템에서 long은 8바이트트 이므로 경우에 따라 이 범위를 넘어가는 경우가 다르다. so 해당 시스템에서 제공할 수 있는 부호 없는 가장 큰 타입인 unitmax_t를 사용하자.

## char
- 부호있는 정수를 저장할때는 sign과 unsigned기호를 붙여주고 문자의 경우에는 그냥 사용하자.

## %
- %연산자는  피지수의 부호를 따라간다.(cf.나눗셈) 그렇기 때문에 해당 데이터의 자료형을 필요시 unsigend 형으로 해주자.

## 비트 필드와 비트 연산자
- 비트 필드에 대하여 정수 타입의 부호는 구현(컴파일러)마다 다르다. 따라서 비트 필드의 부호가 있는지 없는지를 가정하고 구현하면 안된다.
- 비트 연산자(>>, <<, &, |, ~, ^)는 부호 있는 정수에 대하여 구현이 다르게 정의되어 있다. 따라서 정수 피연산자에 대한 비트 연산은 반드시 부호 없는 정수에 대해서만 사용해야 한다.

## 정수래핑(wrap around) vs 오버 플로우 (0522-B,C,I)
- 두 경우 모두 사전에 태스트를 해야 한다.
- 부호 없는 정수끼리의 계산에서는 정수 래핑이 발생한다.(넘어가면 %로 값을 줄인다.) int unsigned와 int와의 계산에서는 unsigned int로 형변환 되니 여기에 해당 될 듯
- 부호가 있는 정수에 대해서는 오버플로우가 발생한다. 위로 넘어가는 것 뿐만 아니라 아래로 넘어가는 것 또한 포함한다. 또한 다른 자료형으로 넘어갈때도 해당될 수 있다.

## 기타
1. 자바나 c++같은 객체 지향 언어는 객체를 생성한다 해서 쓰레드가 바로 돌지는 않음. 운영체제는 쓰레드를 생성만 하면 그 즉시 돈다.
2. &&와 ||에서 경우에 따라 뒤에 것이 연산이 안되는 것이 있음 조심.
3. 함수의 반환값이 임시 객체 형태로 남아 있는데 그곳에 바로 접근하지 말고 변수에 담아둔 다음 접근하자.
4. malloc에 음수가 들어가면 그것을 unsigned 로 받아 무지막지하게 큰 범위를 할당하라는 명령어가 되기때문에, 할당 되지 않는다.
5. 부동 소수 2진수로 찍기(0522-E)

