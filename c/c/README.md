# 놓치기 쉬운 C 개념

# 단계

1. a.c(소스코드,원시코드,텍스트(사람이 볼수 있다는 뜻)->cpp(c Preprocessor)
2. a.i(전처리된 파일 또는 코드, 텍스트)->c compiler
3. a.asm(어셈블리 코드, 텍스트)
4. a.obj(목적파일)
- 어떠한 언어를 다른 언어로 만드는 것을 컴파일러라고 한다. 즉, c언어에서 목적 파일로 되는 것을 컴파일이라고 하지 않는다.
기계어와 1대1로 대응되며 사람이 읽을 수 있는 언어를 니모닉 언어라고 한다. 그 중 하나가 어셈블리 언어다. c언어를 어셈블리어로 만든 것을 컴파일이라 하며 어셈블리 언어로 부터 목적파일이 만들어지는 것은 별개의 일이다. 컴파일이 끝나면 어셈블리와 1대1로 대응되는 기계어(목적 파일)이 생성되니 착각하는 것


## 포인터
1. 보이드 포인터 : 모든 타입을 다 담을 수 있다. but 타입의 안정성이 떨어진다. ->다른 언어들은 reflector 가지고 현재 객체가 무슨 객체인지 알 수 있음.

## 주소
hdd로부터 램에 로드를 한다음 거기로 부터 cpu가 접근을 해야 하는데, 그러기 위해 주소를 사용함(방 번호)
와이어의 갯수가 n일때 방의 갯수는 2의 n승이다.
주소란 렘이란 주기억 장치에 접근하기 위해 부여한 방번호인데, 0부터 시작하는 양의 정수이다.
윈도우 xp는 32비트 운영체제.(cpu가 한번에 처리할 수 있는 단위) ram으로 부터 데이터를 끌어올때 좋던 싫던 32비트씩 가져옴.(주소를 할당해주는 선을 주소선, 데이터를 가져오는 선을 데이터 선이라 한다.) 데이터 선이 32가닥
->너무 비싸다. so 데이터선을 주소선과 공유 즉 2의 32승 즉 4g즉 4g바이트 그래서 윈도우에서는 4g이상의 렘을 사용해도 의미가 없음.(4g이상 할당할 수가 없다.)
->정수의 승격이 되는 이유 char c=64 이라 해서 1바이트 할당 노노, 32가닥으로 즉 인티저 형으로 승격됨.
## 주소 연산
운영체제는 프로그래밍을 실행할때 가상메모리를 잡아준다. 만약 프로그래밍이 실행하다가 운영체제가 허가하지 않은 메모리에 접근하면 운영체제는 프로그램을 죽여버린다.
즉, 주소끼리의 덧셈은 무의미한 값이 나올 가능성이 높아 포인터끼리의 덧셈을 막아놓는다. but 뻴셈은 유의미 하다. 두 주소간의 거리를 알 수 있기때문에 유의미하다. 두 위치사이의 뺄셈은 양의 개념인 정수가 나온다. (not 위치 개념)
## 배열 4종류
1. 그냥 스택에 다 때려박는 경우(매우 무거움)
2. 열만 고정하는 경우 : 힙에 있지만 낭비가 심하고 재활용성 떨어짐
3. 행은 스택에 열은 힙에 놓는 경우 : 여전히 무거움
4. 행과 열 모두 힙에 놓는 경우 : 
->2중 포인터로 배열 구현한거(zagged array 톱니바퀴 행렬) : 배열이 아님 연속적이지 않음. 중간에 겝이 있음. (자바에서 만든 2차형 배열이 이런식임:연속적이라고 가정하지 말라고 써 있음.)

- 배열의 이름은 시작 주소를 의미하는 상수 포인터이다. 
(타입 : int *const p) 
- 예외가 되는 것은 sizeof연산자를 사용할때다.

## 매크로
1. 메크로의 경우 리터럴의 경우는 컴파일이 다 끝나서 나옴 즉, 2*2가 아니라 4로.피연산자가 상수만 있는 것을 상수 표현식이라고 하는데, 이런 표현식은 컴파일 단계에서 다 끝나버림.
2. 함수를 호출하는 것도 무겁기 때문에(인수가 스택에 쌓이는 등) 매크로를 잘 사용하면 좋지만 주의 할 점 3가지
- 매크로를 견고하게 만드는 방법 1. 매크로 함수의 모든 인자에 괄호를 사용하라!
- 매크로를 견고하게 만드는 방법 2. 치환될 매크로의 최 외곽에도 괄호를 사용하라!
- 매크로를 견고하게 만드는 방법 3. 매크로 상수에 괄호를 사용하라
  
